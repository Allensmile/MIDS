<header>
<META http-equiv="content-type" content="text/html; charset=windows-1251">
</header>
<body><h1>Использование autoencoder-ов для построения рекомендационной системы</h1>

<h2>Постановка задачи </h2>

<p>Необходимо было разработать рекомендационную систему, которая бы:<ol><li>Была оптимальна с точки зрения скорости работы после обучения модели.</li><li>Требовала бы минимальных затрат на обработку новых поступающих данных. Т.е. чтобы рекомендационной системе не требовалось бы полное переобучение или же дообучение после получения новых данных или же чтобы операции такого рода были бы минимальны (возможно, мы бы теряли в качестве работы, но при этом не требовалось бы существенных затрат на повторное построение модели).</li></ol></p>


<h2>Решение</h2>

<i>Ход поиска решения я опускаю (т.к.  потребовалось потратить существенное время для описания всего анализа текущих решений  и построения удовлетворяющего  решения) и приведу сразу полученное решение.</i> 


<h3>Основные концепции предлагаемого решения </h3>

<p>Как в любой классической рекомендационной системе у нас есть 1) продукты, 2) пользователи и 3) оценки пользователями продуктов.</p> 

<p>Для каждого продукта и пользователя мы определяем вектор в N-мерном пространстве. Т.е. каждый продукт и каждый пользователь представлен у нас точкой в N-мерном пространстве. Используем два пространства. Одно для пользователей, второе – для продуктов. (Вектора идентификаторы пользователей и продуктов.)</p>

<p>Так же используем данные о пользователе, продукте, оценке при построении модели и при получении результатов оценок продуктов для пользователей.</p>  

<p>Например, для набора данных MovieLens 1M мы используем: <ul><li>такие данные о пользователе как,  пол пользователя и возраст;</li><li>или же для фильма (продукта)  мы используем год создания фильма;</li><li>а для выставленной оценки то в какой день недели она была выставлена.</li></ul>

<p>Такие данные эвристически позволяют делать более точные оценки продуктов для пользователей.
Эти данные преобразуются в вектора: <ul><li>данных о пользователе;</li><li>данных о продукте;</li><li>данных об оценке;</li><li>сама оценка или множества оценок (о множестве оценок позже).</li></ul></p>


<h3>Использование autoencoder-ов</h3>

<p>Для получения N-мерных векторов для каждого продукта/пользователя мы используем следующую схему с использованием autoencoder-ов.</p> 

<p>Напомню, что у autoencoder обучается сжимать данные поданные на его входы и представлять входные данные в сжатом виде.)</p>

<p>Мы используем два autoencoder-а. На вход (и как целевое значение) мы подаем список из M (число равное 5-7) записей, каждая из которых представляет собой:
<ol><li>Для autoencoder-а,  <strong>который обучается на данных об оценках пользователей</strong>, мы используем значения: 1) данных о пользователе, выставившем оценку данному продукту (вектор даннах о пользователе); 2) данных оценки, которые выставил пользователь данному продукту (вектор данных об оценке); 3) сами оценки (вектор значений оценки).При этом для данного autoencoder-а все значения задаются для одного продукта (на один цикл обучения), хотя и для разных оценок (которые мы имеем в системе) пользователей этого продукта.</li><li>Для autoencoder-а, <strong>который обучается на данных об оценках продуктов</strong>, мы используем значения: 1) данных о продукте, которые оценил данный пользователь (вектор данных о продукте); 2) данные оценки продукта пользователем (вектор данных об оценке); 3) сами оценки (вектор оценки/оценок).  При этом все значения задаются для одного пользователя и для разных продуктов, которые были оценены  этим данным пользователем.</li></ol></p>

<p>Таким образом, мы получаем в процессе обучения (на каждом шаге обучения) autoencoder-ов на входах (и целевых значениях) список из M оценок:<ol><li>Для одного продукта -- M оценок пользователей, оценивших данный продукт (в первом autoencoder-е).</li><li>Для одного пользователя -- M оценок продуктов, оцененных данным пользователем (во втором autoencoder-е).</li></ol></p>

<p>Также мы получаем, <b>что первый autoencoder кодирует продукт, а второй кодирует пользователя.</b></p>

<img src="autoencoders.png">

<h3>Как получать вектора идентификаторы пользователей и продуктов</h3>
 
<p>Они получаются следующим образом.</p>

<p>После нескольких циклов обучения autoencoder-ов  (порядка 100..1000) мы задаем для второго autoencoder-а значения оценок продуктов одним пользователем (для каждого пользователя задаём K разных вариантов (число порядка 24..64)) или значения оценок пользователей для одного продукта для первого autroencoder-а.</p> 

<p>Допустим, для одного пользователя мы задали K вариантов (случайных) оценок продуктов (второй autoencoder), т.е. сформировали K разных входов для autoencoder-а. При этом мы получили K разных сжатых значений полученных при работе autoencoder-а. (Т.е. мы получили K векторов частичных идентификаторов пользователя) (Понятно, что мы должны строить такой autoencoder, который бы имел средний слой, состоящий из N элементов, т.е. был бы равен размеру вектора идентификатора пользователя/продукта.) Мы находим среднее из этих K значений. Это и будет новое значение вектора идентификатора пользователя, к которому мы будем двигаться от текущего значения вектора идентификатора пользователя. Так мы поступаем для некоторого числа (L1) пользователей и получаем L1 средних значений.</p> 

<p>Аналогично мы получаем L2 средних значений сжатых и autoencoder-ом, обучаемым на оценках пользователей (или кодирующим идентификаторы продукта).</p> 

<p>Если первоначально мы используем  случайные значения векторов идентификаторов пользователей и продуктов, то мы можем двигаться от наших первоначальных значений к полученным L1 и L2 средним сжатым (средние сжатые и будут новыми целевыми векторами идентификаторов).</p> 

<p>Мы используем плавное движение к целевым значениям идентификаторов т.к. autoencoder-ы используют значения векторов идентификаторов для своего обучения и резкое обучение приведет к потере "знаний" autoencoder-а о значениях векторов идентификаторов.</p> 

<p>Для того, чтобы получить удовлетворительные значения для векторов идентификаторов пользователей и продуктов нужно учитывать и ещё один аспект работы autoencoder-ов – это «дыхание» закодированных значений или групповое плавание значений в некоторых пределах. Эта задача достаточно легко решается. Как это осуществляется я не описываю, но этот момент решен с помощью нахождения средних смещений новых полученных векторов идентификаторов пользователей/продуктов относительно предыдущих значению векторов идентификаторов пользователей/продуктов. и далее коррекция предыдущих без учета среднего смешщения.(Смотрите исходных код для получения подробной информации.)</p> 


<h3>Получение оценок продуктов для пользователя</h3>

<p>Когда у нас есть идентификаторы, то они оказываются упорядоченными в N-мерном пространстве пользователей или же продуктов. Близкие продукты/пользователи (исходя из оценок пользователей) находятся на малом растоянии (эвклидова метрика). Далее мы можем использовать нейронную сеть для получения функции предсказания по: 1) вектору идентификатору продукта; 2) данным о продукте; 3) данным о возможной оценке продукта (не самой оценке, а это, например, день недели/время, когда пользователь хочет посмотреть фильм); 4) вектору идентификатору пользователя; 5) данным о пользователе. Используя все эти данные мы обучаем нейронную сеть для предсказания оценки (оценок) которые может дать пользователь данному продукту при данных условиях.</p> 


<h3>Построение модели</h3>

<p>Мы повторяем обучение autoencoder-ов и нейронной сети для аппроксимации функции оценки пользователем продукта. Есть некоторые нюансы холодного старта обучения autoencoder-ов из случайных начальных значений. Предложенные эвристики для решения этих проблем можно найти в предлагаемом исходном коде к статье.</p> 

<p>После обучения мы получаем модель, состоящую из идентификаторов пользователей и продуктов из нейронных сетей – двух autoencoder-ов и нейронной сети предсказания оценки.</p>  


<h3>Работа с системой после получения модели</h3>

<p>После обучения системы мы можем предсказывать оценки для продуктов, которые не оценили пользователи.</p> 

<p>Но также важным моментом  служит возможность того, что мы можем:<ol><li>Добавлять новые оценки и корректировать векторы идентификаторов пользователей и продуктов.</li><li>Добавлять новые продукты и новых пользователей. Т.е. вычислять векторы идентификаторов для новых пользователей и продуктов.</li></ol></p>

<p>Для вычисления векторов новых идентификаторов мы используем autoencoder-ы из полученной модели. При этом мы используем тот же процесс, что и процесс получения векторов идентификаторов при обучении модели, за исключением того, что мы не обучаем encoder-ы на новых данных, а только лишь вычисляет идентификаторы.</p> 

<p>Процесс вычисления идентификаторов может быть использован и при появлении новых оценок. В этом случае мы можем корректировать идентификаторы. В рамках уже обученной модели, т.е. опять же не переобучая/не дообучая autoencoder-ы.</p> 

<p>При вычислении/корректировке идентификаторов мы, конечно же, в целях скорости обработки  не корректируем часть модели задаваемой нейронными сетями. Но новые данные могут и изменять/расширять модель, так что такое изменение/расширение не может быть выраженно только в вычислении векторов идентификаторов пользователей/продуктов, поэтому хорошей эвристикой может быть дообучение модели через некоторый интервал времени (раз в день/неделю/месяц/квартал). Такое дообучение можно производить в пакетном режиме параллельно нормальной работе системы в рамках предсказания оценок, добавления новых продуктов, пользователей, добавления новых оценок.</p>  


<h2>Что дает предложенный подход</h2>

<p>Кроме решения задач, ставившихся в постановке задачи, также данный подход дает возможность вводить в системы машинного обучения память. Здесь под памятью можно понимать непосредственно значения вычисленных идентификаторов. Они в рамках модели могут представлять объекты внешнего мира, неся в себе некоторое описание объекта внешнего мира с точки зрения системы (некоторых оценок системы данным объектам). Такая помять может быть использована для описания объекта.</p> 

<p>Кроме этого данный подход даёт возможность задавать большое количество параметров, которыми определяются векторы идентификаторов пользователей и продуктов, а также параметров оценки. (Возможно, в этом случае имеет смысл использовать эвристику задания степени влияния определенных данных на процесс обучения.)</p> 

<p>(P.S. Looking for a job.)</p>
</body>