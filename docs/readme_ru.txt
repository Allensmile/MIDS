Использование autoencoder-ов для построения рекомендационной системы

Постановка задачи 

Необходимо было разработать рекомендационную систему, которая бы:
1.	Была оптимальна с точки зрения скорости работы после обучения модели.
2.	Требовала бы минимальных затрат на обработку новых поступающих данных. Т.е. чтобы рекомендационной системе не требовалось бы полное переобучение или же дообучение после получения новых данных или же чтобы операции такого рода были бы минимальны (возможно, мы бы теряли в качестве работы, но при этом не требовалось бы существенных затрат на повторное построение модели). 

Решение

Ход поиска решения я опускаю (т.к.  потребовалось потратить существенное время для описания всего анализа текущих решений  и построения удовлетворяющего  решения) и приведу сразу полученное решение. 

Основные концепции предлагаемого решения 

Как в любой классической рекомендационной системе у нас есть продукты, пользователи и оценки пользователями продуктов. 

Для каждого продукта и пользователя мы вводим его представление-точку в N-мерном пространстве. Т.е. каждый продукт и каждый пользователь представлен у нас в виде точки в N-мерном пространстве. Используем два пространства. Одно для  пользователей, второе – для продуктов. (Вектора идентификаторы пользователей и продуктов.)

Так же используем данные о пользователе, продукте, оценке при построении модели и при получении результатов оценок продуктов для пользователей.  (Например, для набора данных MovieLens 1M мы используем: 1) такие данные о пользователе как,  пол пользователя и возраст; 2)  или же для фильма (продукта)  мы используем год создания фильма; 3) а для выставленной оценки то в какой день недели она была выставлена.) Такие данные эвристически позволяют делать более точные оценки продуктов для пользователей. Эти данные преобразуются в вектора: 1) данных о пользователе; 2) данных о продукте; 3) данных об оценке; 4) самой оценке или множества оценок (о множестве оценок позже).

Использование autoencoder-ов

Для получения N-мерных векторов для каждого продукта/пользователя мы используем следующую схему с использованием autoencoder-ов. 

(Напомню, что у autoencoder обучается сжимать данные поданные на его входы и представлять входные данные в сжатом виде.)

Мы используем два autoencoder-а. На вход (и как целевое значение) мы подаем вектор из M (число равное 5-7) значений, каждое из которых представляет собой:
1.	Для autoencoder-а,  который обучается на данных об оценках пользователей, мы используем значения: 1) данных о пользователе, выставившем оценку данному продукту; 2) данных оценки, которые выставил пользователь данному продукту; 3) сами оценки. При этом все значения задаются для одного продукта, хотя и для разных оценок (которые мы имеем в системе) пользователей этого продукта.
2.	 Для autoencoder-а, который обучается на данных об оценках продуктов, мы используем значения: 1) данных о продукте, которые оценил данный пользователь; 2) данные оценки продукта пользователем; 3) сами оценки.  При этом все значения задаются для одного пользователя и для разных продуктов, которые были оценены  этим данным пользователем. 
Таким образом, мы получаем в процессе обучения autoencoder-ов на входах (и целевых значениях) список из M оценок:
1.	Для одного продукта M оценок пользователей, оценивших данный продукт. 
2.	Для одного пользователя M оценок продуктов, оцененных данным пользователем. 


Как получать вектора идентификаторы пользователей и продуктов 

Они получаются следующим образом.

После нескольких циклов обучения autoencoder-ов  (порядка 100..1000) мы опять задаем на каждый из autoencoder-ов значения оценок продуктов одним пользователем (для каждого пользователя задаём K разных вариантов  (число порядка 24..64)) или значения оценок  пользователей для одного продукта. 

Допустим, для одного пользователя мы задали K вариантов оценок продуктов, т.е. сформировали K разных входов для autoencoder-а. При этом мы получили K разных сжатых значений полученных при работе autoencoder-а. (Понятно, что мы должны строить такой autoencoder, который бы имел средний слой, состоящий из N элементов, т.е. был бы равен размеру вектора идентификатора пользователя/продукта.) Мы находим среднее из этих K значений. Так мы поступаем для некоторого числа (L1) пользователей и получаем L средних значений. 

Аналогично мы получаем L2 средних значений сжатых и autoencoder-ом, обучаемым на оценках пользователей (или кодирующим идентификаторы продукта). 

Если первоначально мы используем  случайные значения векторов идентификаторов пользователей и продуктов, то мы можем двигаться от наших первоначальных значений к полученным L1 и L2 средним сжатым (средние сжатые и будут целевыми идентификаторами). 

Мы используем плавное движение к целевым значениям идентификаторов т.к. autoencoder-ы используют значения векторов идентификаторов для своего обучения и резкое обучение приведет к потере знаний autoencoder-а о значениях. 

Для того, чтобы получить удовлетворительные значения для векторов идентификаторов пользователей и продуктов нужно учитывать и ещё один аспект работы autoencoder-ов – это «дыхание» закодированных значений или групповое плавание значений в некоторых пределах. Эта задача достаточно легко решается. Как это осуществляется я не описываю, но этот момент решен с помощью нахождения средних смещений новых полученных векторов идентификаторов пользователей/продуктов по отношению к предыдущему значению векторов идентификаторов пользователей/продуктов. (Смотрите исходных код для получения подробной информации.) 

Получение оценок продуктов для пользователя

Когда у нас есть идентификаторы, то они оказываются упорядоченными в N-мерном пространстве пользователей или же продуктов. Далее мы можем использовать нейронную сеть для получения функции предсказания по: 1) вектору идентификатору продукта; 2) данным о продукте; 3) данным о возможной оценке продукта (не самой оценке, это, например, день недели/время, когда пользователь хочет посмотреть фильм); 4) вектору идентификатору пользователя; 5) данным о пользователе. Используя все эти данные предсказать оценку (оценки) которую может дать  пользователь данному продукту при данных условиях. 


Построение модели

Мы повторяем обучение autoencoder-ов и нейронной сети для аппроксимации функции оценки пользователем продукта. Есть некоторые нюансы холодного старта обучения autoencoder-ов из случайных значений. Предложенные эвристики для решения этих проблем  можно найти в предлагаемом исходном коде к статье. 

После обучения мы получаем модель, состоящую из идентификаторов пользователей и продуктов из нейронных сетей –   двух autoencoder-ов и нейронной сети предсказания оценки.  


Работа с системой после получения модели

После обучения системы мы можем предсказывать оценки для продуктов, которые не оценил пользователь. 

Но также важным моментом  служит возможность того, что мы можем: 
1.	Добавлять новые оценки и корректировать векторы идентификаторов пользователей  и продуктов. 
2.	Добавлять новые продукты и новых пользователей. Или вычислять векторы идентификаторов новых пользователей и продуктов. 

Для вычисления векторов новых идентификаторов мы используем autoencoder-ы из полученной модели. При этом мы используем тот же процесс, что и процесс получения векторов идентификаторов при обучении модели, за исключением того, что мы не обучаем encoder-ы на новых данных, а только лишь вычисляет идентификаторы. 

Процесс вычисления идентификаторов моет быть использован и при появлении новых оценок. В этом случае мы можем корректировать идентификаторы. В рамках уже обученной модели. 

При вычислении/корректировке идентификаторов мы, конечно же, в целях скорости обработки  не корректируем часть модели задаваемой нейронными сетями. Но новые данные могут и изменять/расширять модель, так что такое изменение/расширение не может быть выраженно только в вычислении векторов идентификаторов пользователей/продуктов, поэтому хорошей эвристикой может быть дообучение модели через некоторый интервал времени (раз в день/неделю/месяц/квартал). Такое дообучение можно производить в пакетном режиме параллельно нормальной работе системы в рамках предсказания оценок, добавления новых продуктов, пользователей, добавления новых оценок.  


Что дает предложенный подход

Кроме решения задач, ставившихся в постановке задачи, также данный подход дает возможность вводить в системы машинного обучения память. Здесь под памятью можно понимать непосредственно значения вычисленных идентификаторов. Они в рамках модели могут представлять объекты внешнего мира, неся в себе некоторое описание объекта внешнего мира с точки зрения системы. 

Кроме этого данный подход даёт возможность задавать большое количество параметров, которыми определяются векторы идентификаторов пользователей и продуктов. 










